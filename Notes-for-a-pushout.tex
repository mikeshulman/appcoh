\documentclass[12pt]{amsart}

% packages

\usepackage{amsfonts, amsthm, amssymb, amsmath, stmaryrd, etoolbox, mathtools}
\usepackage{graphicx,caption,subcaption}
\usepackage{tikz}
\usetikzlibrary{matrix,arrows}

% new commands

\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\from}{\colon}
%\newcommand{\defn}[1]{\textbf{#1}}
\newcommand{\tin}{\colon}

% fonts
\newcommand{\cat}[1]{\mathbf{#1}}
\newcommand{\type}[1]{\mathtt{#1}}

% types
\newcommand{\A}{\type{A}}
\newcommand{\B}{\type{B}}
\newcommand{\C}{\type{C}}
\newcommand{\Type}{\type{Type}}
\newcommand{\ap}{\type{ap}}
\newcommand{\inl}{\type{inl}}
\newcommand{\inr}{\type{inr}}
\newcommand{\glue}{\type{glue}}
\newcommand{\refl}{\type{refl}}
\newcommand{\code}{\type{code}}
\newcommand{\encode}{\type{encode}}
\newcommand{\decode}{\type{decode}}


% math operators
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\ob}{Ob}
\DeclareMathOperator{\arr}{arr}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\Aut}{Aut}
\DeclareMathOperator{\Bij}{Bij}
\DeclareMathOperator{\Sub}{Sub}

% theorem styles
\newtheorem{lemma}{Lemma}
\newtheorem{thm}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{cor}{Corollary}
\theoremstyle{remark}
\newtheorem{rmk}{Remark}
\theoremstyle{definition}
\newtheorem{defn}{Definition}

\newtheorem{ex}{Examples}

%%%%%%%%%%%%%
% begin document
%%%%%%%%%%%%%
\begin{document}

\title{Notes on a pushout of sets}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
\section{HoTT concepts}

\begin{defn} % def : set
	\label{def:set}
	A \textbf{set} is a type $ \type{S} $ such that
	for any elements $ x,y \tin \type{S} $,
	and $ p,q \tin x = y $, we have $ p = q $.
\end{defn}

\begin{defn} % def : ap
	\label{def:ap}
	Let $ f \from \type{ A } \to \B $.
	For any $ x,y \tin \type{ A } $, we get a function 
	\[
	\ap_f \from 
	x =_\A y \to fx =_\B fy
	\]
	on identity types.  
	
	This can be interpreted in three ways:
	\begin{enumerate}
		\item type morphisms preserve equality,
		\item functions of spaces are continuous,
		\item groupoid morphisms given functions
		on hom-sets.
	\end{enumerate}
	Because $ \type{ ap } $ preserve paths, 
	all functions in HoTT are continuous.
	There are more results showing that
	$ f $ is functorial in that it preserves
	refl's and path concatenation.
	
	\emph{Note: we can take the categorical
		notation and write $ f ( p ) $ for a path
		$ p \tin x = y $ instead of 
		$ \type{ ap }_f ( p ) $, 
		but for now we stick with the latter.}
\end{defn}

\begin{defn} % def : higher induction
	Types can be defined by constructors.
	For example the circle type $ \type{S}^1 $
	is given by a $ 0 $-cell $s$ and 
	a $ 2 $-cell $ p \tin s = s $.
	
	Higher induction says that to define
	a map out of such a type, it suffices
	to define the map on the constructors.
	Hence a map 
	\[
		f \from \type{ S }^1 \to \type{ A }
	\] 
	is given by $ f ( s ) $ and 
	$\type{ ap }_f ( p )$.
\end{defn}

\begin{defn} % def : pushout
\label{def:pushout}
	Given a span
	\[
	\begin{tikzpicture}
		\node (A) at (0,0) {$\A$};
		\node (B) at (1,0) {$\B$};
		\node (C) at (0,-1) {$\C$};
		\draw [->] (A) to 
			node [above] {\scriptsize $ f $} 
			(B);
		\draw [->] (A) to 
			node [left] {\scriptsize $ g $} 
			(C);
	\end{tikzpicture}
	\]
	its pushout $ \type{B +_A C} $ is defined by
	\begin{itemize}
		\item a function 
			$ \type{ inl } \from \B \to \type{B +_A C} $
		\item a function 
			$ \type{ inr } \from \C \to \type{B +_A C} $
		\item for each $ a \in \A $ and path
			$ \type{ glue } ( a ) \tin fa = ga $
	\end{itemize}
	Hence, all functions $F \from \type{B +_A C} \to \type{D}$
	are given by higher induction:
	\begin{itemize}
		\item define $ F ( \type{ inl } (b) ) $
			for all $ b \tin \B $
		\item define $ F ( \type{ inr } (c) ) $
			for all $ c \tin \C $
		\item define 
			$ \type{ ap }_{ F } ( \type{ glue} ( a ) ) \tin 
			 F ( \type{ inl } (fa) ) = F ( \type{ inr } (ga) ) $
			for all $ a \tin \type{ A } $
	\end{itemize}
\end{defn}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
\section{the setup}

The idea is that we have types 
$A$, $B$, and $C$, all of which are sets. 
The question: is the pushout given by the square
\[ % pushoutsquare
	\begin{tikzpicture}
		\node (C) at (0,0) {$C$};
		\node (BAC) at (2,0) {$B +_A C$};
		\node (A) at (0,2) {$A$};
		\node (B) at (2,2) {$B$};
		\draw[right hook ->]  (A) to node [above] {\scriptsize $f$} (B);
		\draw[->]  (A) to node [left] {\scriptsize $g$} (C);
		\draw[->]  (B) to node [right] {\scriptsize $\inl$} (BAC);
		\draw[->]  (C) to node [above] {\scriptsize $\inr$} (BAC);
	\end{tikzpicture}
\]
also a set when $f$ is a monomorphism?

Thus to determine whether $B +_A C$ is a set,
we need to access its identity types.  
We do this with an \emph{encode-decode} style proof.  

Roughly, a proof of this sort begins by guessing
what the identity types are.  That is,
for each $x$ and $y$ in $B +_A C$, 
we define a type 
\[
	\code \from B +_A C \to B +_A C \to \Type
\]
so that $\code(x,y)$ serves as our guess  
as to what $x =_{\scriptsize B +_A C} y$ actually is.  
Then we define functions
\[
	\type{ encode }_{ x , y } \from  ( x = y ) \to \code ( x , y ) 
	\text{ and }
	\type{ decode }_{ x , y } \from \code ( x , y ) \to ( x = y )
\]
for each $x$ and $y$ in $B +_A C$.  
Hopefully, these are mutually inverse.

% %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
\section{defining $\code$}

Let's try to define 
\[
	\code \from 
	B +_A C \to B +_A C \to \Type.
\]  
Note that $\code$ is a map from a pushout, 
so we define it using induction of higher types, 
as in Definition \ref{def:pushout}.
Hence we need three types schemes:
\begin{align*}
	\code(\inl(b)) & \from B +_A C \to \Type \\
	\code(\inr(c)) & \from B +_A C \to \Type \\
	\code(\type{ap_{glue}}(a)) & \from B +_A C \to \Type \\
\end{align*}
These schemes run through 
$a \tin A$, $b \tin B$, and $c \tin C$.  
They are also functions on the same coproduct!
To define $\code(\inl(b))$, 
we use higher induction which gives the type schemes:
\[
	\code(\inl(b),\inl(b')), \hspace{0.5em}
	\code(\inl(b),\inr(c')), \hspace{0.5em}
	\code(\inl(b),\type{ap_{glue}}(a')).
\]
Similarly, we define $\code(\inr(c))$ by
\[
	\code(\inr(c),\inl(b')), \hspace{0.5em}
	\code(\inr(c),\inr(c')) , \hspace{0.5em}
	\code(\inr(c),\type{ap_{glue}}(a')).
\]
and $\code(\glue(a))$ by 
\[
	\code(\type{ap_{glue}}(a),\inl(b')), \hspace{0.5em}
	\code(\type{ap_{glue}}(a),\inr(c')) , \hspace{0.5em} 
	\code(\type{ap_{glue}}(a),\type{ap_{glue}}(a')).
\]
The $\code$'s that have 
no $\type{ap_{glue}}$'s in the arguments 
correspond to our guesses
for the identity types.
The $\code$'s that have 
one $\type{ap_{glue}}$ in the arguments
give a pre- or post-composition
of paths.
The $\code$'s that have 
two $\type{ap_{glue}}$'s in the arguments  
ensure that this pre- and post-composition
action is coherent.
This fits together in a nice little 
diagram:
\[ % coherence diagram for code
	\begin{tikzpicture}
		\node (AA) at (0,0) 
			{ $ \simeq \type{ code } ( \type{ ap_{glue} } ( a ) , \type{ ap_{glue} } ( a' )  )$ }; 
		\node (BB) at (-4,2) 
			{ $ \type{ code } ( \type{ inl } ( b ) , \type{ inl } ( b' )  )$ }; 
		\node (BC) at (4,2) 
			{ $ \type{ code } ( \type{ inl } ( b ) , \type{ inr } ( c' )  )$ }; 
		\node (CB) at (-4,-2) 
			{ $ \type{ code } ( \type{ inr } ( c ) , \type{ inl } ( b' )  )$ }; 
		\node (CC) at (4,-2) 
			{ $ \type{ code } ( \type{ inr } ( c ) , \type{ inr } ( c' )  )$ }; 
		\draw [->] (BB) to 
			node 
				[above] 
				{\scriptsize $ \type{ code } ( \type{ inl } ( b ) , \type{ ap_{glue} } ( a' ) $ } 
			(BC);
		\draw [->] (BB) to 	
			node 
				[rotate=90,above] 
				{ \scriptsize $ \type{ code } ( \type{ ap_{glue} } ( a ) , \type{ inl } ( b' ) $ } 
			(CB);
		\draw [->] (BC) to 
			node 
				[rotate=-90, above] 
				{\scriptsize $\type{ code } ( \type{ ap_{glue} } ( a ) , \type{ inr } ( c' ) $} 
			(CC);
		\draw [->] (CB) to 	
			node 
				[below] 
				{ \scriptsize $ \type{ code } ( \type{ inr } ( c ) , \type{ ap_{glue} } ( a' ) $ } 
			(CC);
	\end{tikzpicture}
\]

\textbf{Define the coherence 0-cells }

\fbox{ % code (inl b, inl b')
\begin{minipage}{\textwidth}
$\type{ code } \left( \type{ inl } ( b ) , \type{ inl } ( b' ) \right)$ is the most complicated. 
In order to incorporate $\type{ refl }_b$ when $b$ is not in the image of $f$, 
we define this type to be the pushout of the span
\[
\begin{tikzpicture}
	\node (1) at (0,2) 
		{ $ \sum_{ a , a' : A } 
			( b =_B f ( a ) ) 
			\times ( b' =_B f ( a' ) ) 
			\times ( b =_B b' ) $ };
	\node (2) at (6,2) 
		{ $ ( b =_B b' ) $ };
	\node (3) at (0,0) 
		{ $ \sum_{ a , a' : A } 
			( b =_B f ( a ) ) 
			\times  (b' =_B f ( a' ) ) 
			\times ( g ( a ) =_C g ( a' ) ) $ };
	\draw [ -> ] (1) to 
		node [above] {\scriptsize $ \alpha $} 
		(2);
	\draw [ -> ] (1) to 
		node [above] {\scriptsize $ \beta $}
		(3);
\end{tikzpicture}
\]
Here, $ \alpha $ is a projection. Also,
$ \beta $ is a projection of the first
two factors and places $ \type{ ap }_g (p) $ 
in the third factor. This uses the injectivity of $f$
to get a $ p \tin a = a' $ if the upper left
is populated.

This is a proposition. 
Indeed, the span feet are propositions
and the only way for both to be populated
is if the apex is also populated.
But this would identify the 
left and right included elements
with a glue.
\end{minipage}
}

\fbox{ % code (inl b, inr c')
\begin{minipage}{\textwidth}
$
\type{ code } \left( \type{ inl } ( b ) , \type{ inr } ( c' ) \right) \coloneqq
	\sum_{ a : A } ( b =_B f ( a ) ) \times ( c' =_C g ( a ) )
$
This is a proposition. 
Indeed, if there does not exist an $ a : A $ such that
$ b =_B f ( a )$ and $ c' =_C g ( a ) $
are both populated, then 
$ \type{ code } \left( \type{ inl } ( b ) , \type{ inr } ( c' ) \right) $ 
is empty. 
If there exists a single $a : A$ such that 
$ b =_B f ( a )$ and $ c' =_C g ( a ) $
are both populated, then 
because they are each equivalent to $ \type{ 1 }$,
$ \type{ code } \left( \type{ inl } ( b ) , \type{ inr } ( c' ) \right) $ 
is also equivalent to $ \type{ 1 }$.
If there is $a, a' : A$ such that
$ b =_B f ( a )$ and $ c' =_C g ( a ) $,
and also 
$ b =_B f ( a' )$ and $ c' =_C g ( a' ) $,
then the injectivity of $f$ and
$f ( a ) =_B b =_B f ( a' )$ 
implies that
$a =_A a'$
which also gives us that 
$ \type{ code } \left( \type{ inl } ( b ) , \type{ inr } ( c' ) \right) $ 
is equivalent to $ \type{ 1 }$.
\end{minipage}
}

\fbox{ % code (inr c, inl b')
\begin{minipage}{\textwidth}
	$
	\type{ code } \left( \type{ inr } ( c ) , \type{ inl } ( b' ) \right) \coloneqq
	\sum_{ a : A } ( c =_C g ( a ) ) \times ( b' =_B f ( a ) )
	$
	This is a proposition by the same sort of argument from above.
\end{minipage}	
}

\fbox{ % code (inr c, inr c')
\begin{minipage}{\textwidth}
	$
	\type{ code } \left( \type{ inr } ( c ) , \type{ inr } ( c' ) \right) \coloneqq
	\sum_{ a , a' : A } ( c =_C g ( a ) ) \times ( c' =_C g ( a' ) ) \times ( f ( a ) =_B f ( a' ) )
	$ 	
	The injectivity of $f$ gives us that 
	$ f ( a ) =_B f ( a' ) $
	imples that 
	$ a =_A a'$
	which in turn implies that
	$ g ( a ) =_C g ( a' )$,
	hence 
	$ c =_C c'$.
	Therefore, 
	$
	\type{ code } \left( \type{ inr } ( c ) , \type{ inr } ( c' ) \right) =	
	\left( c =_C c'  \right). 
	$
	Hence 
	$ \type{ code } \left( \type{ inr } ( c ) , \type{ inr } ( c' ) \right) $
	is a proposition.
\end{minipage}
}
	

\textbf{Define the coherence 1-cells }

These are all equivalences, hence by univalence
we define them as identity types. 
To show this, we show each is populated.

\fbox{ % code (inl b , glue a')
\begin{minipage}{\textwidth}
	$ 
	\type{ code } \left( \type{ inl } ( b ) , \type{ ap }_{ \type{ glue } } ( a' ) \right) \colon
	\left(
	\type{ code } ( \type{ inl } ( b ) , \type{ inl } ( f ( a' ) ) ) =
	\type{ code } ( \type{ inl } ( b ) , \type{ inr } ( g ( a' ) ) ) 
	\right)
	$
	Because both sides of the identity type are propositions,
	to show that this equivalence holds
	it suffices to show that either
	$\type{ code } ( \type{ inl } ( b ) , \type{ inl } ( f ( a' ) ) )$
	and
	$\type{ code } ( \type{ inl } ( b ) , \type{ inr } ( g ( a' ) ) )$
	are both empty or both populated.
	This follows from post-composition with
	$ \type{ glue ( a' ) }$
	or its inverse.	
\end{minipage}
}

\fbox{ % code ( glue a , inl b')
\begin{minipage}{\textwidth}
	$ 
	\type{ code } \left( \type{ ap }_{ \type{ glue } } ( a ) , \type{ inl } ( b' ) \right) \colon
	\left(
	\type{ code } ( \type{ inl } ( f ( a ) ) , \type{ inl } ( b' ) ) =
	\type{ code } ( \type{ inr } ( g ( a ) ), \type{ inl } ( b' ) ) 
	\right)
	$
	This follows from a similar argument to that above, 
	with post-composition replaced with pre-composition.
\end{minipage}
}

\fbox{ % code (inr c , glue a')
\begin{minipage}{\textwidth}
	$ 
	\type{ code } \left( \type{ inr } ( c ) , \type{ ap }_{ \type{ glue } } ( a' ) \right) \coloneqq
	\left( 
	\type{ code } ( \type{ inr } ( c ) , \type{ inl } ( f ( a' ) ) ) =
	\type{ code } ( \type{ inr } ( c ) , \type{ inr } ( g ( a' ) ) ) 
	\right) 
	$ 
	This follows from a similar argument.	
\end{minipage}
}

\fbox{ % code ( glue a , inr c')
\begin{minipage}{\textwidth}
	$ 
	\type{ code } \left( \type{ ap }_{ \type{ glue } } ( a ) , \type{ inr } ( c' ) \right) \coloneqq 
	\left( 
	\type{ code } ( \type{ inl } ( f ( a ) ) , \type{ inr } ( c' ) ) =
	\type{ code } ( \type{ inr } ( g ( a ) ) , \type{ inr } ( c' ) ) 
	\right) 
	$ 
	This follows from a similar argument.	
\end{minipage}
}

\textbf{Define the coherence 2-cell}

\fbox{ % code (glue a , glue a')
\begin{minipage}{\textwidth}
	$\type{ code } ( \type{ ap }_\type{ glue } ( a ) , \type{ ap }_\type{ glue } ( a' )  )$ is uniquely determined because
	everything involved is a proposition. 
	Because we have that the 1-cells 
	in the square are equalities,
	there is only a single way to commute.
	This single way is how we define our 2-cell.
\end{minipage}
}

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
\section{defining $\encode$}

Now that $ \code $ is defined, we define maps between it and the identity types inside of $ B+_A C $. The first map we consider is encode, which is of type
\[
	\encode : 
		\prod_{x : B+_AC} \prod_{y : B+_AC} 
		(x=_{B+_AC} y) \to  \code (x,y).
\]
What are the non-empty identity types in $ B+_A C $ that $ \encode $ must map from?  
\begin{itemize}
	\item for $ b,b' : B $ and $ p : b =_B b'  $, a path 
	\[
		\ap_{\inl}(p) : \inl (b) =_{B+_AC} \inl (b')
	\]
	%
	\item for $ c,c' : C $ and $ q : c =_C c'  $, a path  
	\[
		\ap_{\inr}(q) : \inr (c) =_{B+_AC} \inl (c') 
	\]
	%
	\item for $ a : A $, a path  
	\[
		\glue (a) : \inl(fa) =_{B+_AC} \inr(ga)
	\] 
\end{itemize}

Thus it suffices to define the value of $ \encode $ for $ \ap_{\inl}(p) $, $ \ap_{\inr}(q) $, and $ \glue (a) $.  

Also, since we are mapping out of identity types, we can use path induction.

\begin{itemize}
	%___________
	\item Define 
	\[
		\encode \from (\inl (b) =_{B+_AC} \inl (b)) \to \code (\inl(b),\inl(b))
	\] 
	by $ \refl_b \mapsto \ap_\inl (\type{refl_b})  $. Note that this $ \inl $ is coming from the span used to define $ \code(\inl(b),\inl(b)) $
	%____________
	\item Define 
	\[
		\encode \from (\inr (c) =_{B+_AC} \inr (c)) \to \code (\inr(c),\inr(c))
	\] 
	by $ \refl_c \mapsto \ap_\inr (\refl_c)  $. Note that this $ \inr $ is coming from the span used to define $ \code(\inr(c),\inr(c)) $.
	%____________
	\item Define 
	\[
		\encode \from (\inl (fa) =_{B+_AC} \inr (ga)) \to \code (\inl(fa),\inr(ga))
	\]
	by $ \glue (a) \mapsto ( \refl_{fa} , \refl_{ga}) $
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
\section{defining $\decode$}

Define 
\[
	\decode : 
	\prod_{x : B+_AC} \prod_{y : B+_AC} 
	\code (x,y) \to (x=_{B+_AC} y).
\]
We can't use path induction because we are not mapping out of an identity type. The general strategy will be to give values for $ \decode $ when feeding it the four different types of inputs--- $ b/b' $, $ c/c' $, $ b/c $, and $ c/b $---as well as higher paths coming from $ \glue $.  Of the former four, $ b/b' $ is the most difficult because of the complicated definition for $ \code (\inl b , \inl b') $.  When dealing with $ \glue $, we must ensure naturality, meaning that there will be commuting diagrams to check.

\begin{itemize}
	%____________
	\item The type
	\[
		\decode ( \inr c , \inr c') \from 
		\code ( \inr c , \inr c' ) \to ( c =_{\B +_{\A} \C}) c' )
	\]
	is given by $ p \mapsto \ap_{\inl} p $
	%____________
	\item The type 
	\[
		\decode ( \inl b , \inr c ) \from 
		\code ( \inl b , \inr c ) \to ( b =_{\B +_{\A} \C}) c )
	\]
	is trivial unless $ b = fa $ and $ c = ga $ hold. Define
	\[
		\decode ( \inl b , \inr c ) \from 
		\code ( \inl fa , \inr ga ) \to ( fa =_{\B +_{\A} \C}) ga )
	\]
	given by $ (p,q) \mapsto (\ap_{\inr} q^{-1}) (\glue a) (\ap_{\inl} p)$.
	%_______________
	\item The type 
	\[
		\decode ( \inr c , \inl b ) \from 
		\code ( \inr c , \inl b ) \to ( c =_{\B +_{\A} \C}) b )
	\]
	is trivial unless $ b = fa $ and $ c = ga $ hold. Define
	\[
		\decode ( \inr c , \inl b ) \from 
		\code ( \inr ga , \inl fa ) \to ( ga =_{\B +_{\A} \C}) fa )
	\]
	given by $ (q,p) \mapsto (\ap_{\inl} p^{-1}) (\glue a) (\ap_{\inr} q) $.
	%______________
	\item The type 
	\[
		\decode ( \inl b , \inl b' ) \from 
		\code ( \inl b , \inl b' ) \to ( b =_{\B +_{\A} \C}) b' )
	\]
	is more involved because $ \code ( \inl b , \inl b' ) $ is a pushout.  To define a map out of a pushout, define it on the constructors.  Hence, to define $ \decode ( \inl b , \inl b' ) $ we need to produce values for
	\begin{itemize}
		\item $ \decode ( \inl b , \inl b' ) (\inl p) $ for $ p : b =_{\B} b' $
		\item for each $ a,a' : \A $, define $ \decode ( \inl b , \inl b' ) (\inr (p,q,r)) $ for $ p : (b +_{\B} fa) $, $ q : (b' =_{\B} fa') $, and $ r : (ga =_{\C} ga') $, and
		\item $ \ap_{\decode ( \inl b , \inl b' )} (\glue a)  $ for $ a : \A $.
	\end{itemize}
	%______________
\end{itemize}

Now let's make the definitions.
\begin{itemize}
	\item $ \decode ( \inl b , \inl b' ) (\inl p) = \ap_{\inl} \inl p$
	\item $ \decode ( \inl b , \inl b' ) (\inr (a,a',p,q,s)) = 
		(\ap_{\inl} q) (\glue a'^{-1}) (\ap_{\inr} r) (\glue a) ( \ap_{\inl} p)$
		We need to check that this is well defined.  Here, that means ensuring that an element of $ \code (\inl b , \inl b') $ coming from 
		\[
		\sum_{a,a' : 'A} 
			(b =_{\B} fa) \times 
			(b' =_{\B} fa') \times 
			(b =_{\B} b')
		\]
		has the same output under $ \decode $ regardless if it travels via the pushout maps $ \alpha $ or $ \beta $.  Let's take an element
		\[
		(a,a',p,q,r) :
			\sum_{a,a' : 'A} 
			(b =_{\B} fa) \times 
			(b' =_{\B} fa') \times 
			(b =_{\B} b').
		\]
		\begin{itemize}
			\item Under $ \alpha $, we have that $ \alpha (a,a',p,q,r) \coloneqq r $ which $ \decode (\inl b , \inl b') (\inl r) \coloneqq \ap_{\inl} r$.
			\item Under $ \beta $, we have that $ \beta (a,a',p,q,r) \coloneqq (a,a',p,q, \ap_g s) $.  What is $ s $? Since $ r : (b =_{\B} b') $, then $ qrp^{-1} : fa =_{\A} f'a $. By the injectivity of $ f $, there exists $ s : a =_{\A} a' $.   Then $ \decode (\inl b , \inl b') $ sends this to 
			\[
			( \ap_{inl} q )( \glue a'^{-1} )( \ap_{\inr} \ap_{g} s )( \glue a )( \ap_{\inl} p )
			\]
			{\color{red}ARE THESE EQUAL?}
		\end{itemize}
		
		
		
		
\end{itemize} 







%%%%%%%%%%%%%
% end document
%%%%%%%%%%%%%




\end{document}
